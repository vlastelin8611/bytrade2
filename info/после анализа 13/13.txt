Чтобы выяснить, почему «программа‑торговец» генерирует только 4 сигнала и эти сигналы висят в очереди без исполнения, я изучил обновлённый проект **bytrade2** в GitHub. Ниже — ключевые моменты и рекомендации (я не менял код, а только анализировал):

### 1. Формирование сигналов

* **Количество сигналов.** В генераторе сигналов `SignalGenerator` минимальный порог уверенности снижен до `0.1`, анализируется до 200 USDT‑пар и возвращается до 50 сигналов. При этом учитываются пары с изменением цены или объёмом и добавляется список «популярных» монет. Файл `adaptive_ml_performance.json` содержит сотни торговых пар с точностью ML‑моделей, поэтому при нормальных данных сигналов должно быть значительно больше четырёх. Если их мало, вероятные причины:

  * API тестнета возвращает для большинства пар нулевое поле `price24hPcnt` и объём `volume24h`, поэтому они отсекаются как неактивные. В журнале вы можете увидеть, сколько активных пар найдено.
  * Файл `adaptive_ml_performance.json` загружается, но файл `adaptive_ml_training_state.json` отсутствует, поэтому ML‑данные могут быть частично пусты.
  * Если `ticker_data` приходит как словарь без вложенного списка, функция `get_usdt_pairs` всё равно выделит USDT‑пары, но активными считает только пары с изменением цены или объёмом.

### 2. Неисполнение сигналов

* **Торговля по умолчанию выключена.** В классе `TraderMainWindow` торговый движок стартует автоматически только если передан флаг `--enable-trading` или нажата кнопка «Запустить автоматическую торговлю». В противном случае журнал сообщает: «Торговля не включена при запуске». Если запустить программу без этого флага, сигналы будут генерироваться и сохраняться, но `process_signal` их игнорирует, и они зависают.

* **Проверка успешности ордеров.** Методы `execute_buy_order` и `execute_sell_order` считают ордер успешным, только если в ответе API присутствует поле `retCode == 0`. Однако клиент `BybitClient.place_order` возвращает только объект `result` без `retCode`, поскольку `_make_request` вырезает код возврата и отдаёт лишь `data.get('result', {})`. Из‑за этого даже успешные заявки трактуются как неудачные, и сигнал остаётся в статусе «PENDING» до тех пор, пока не исчерпает три попытки и не будет удалён. В журнале это проявляется как повторяющееся сообщение «Сигнал BUY для … не исполнен».

* **Проверки средств и лимитов.** При покупке берётся минимальная сумма от 1 % баланса USDT, но не меньше минимально допустимой и не больше заданного максимума. Далее количество `qty` рассчитывается как `trade_amount / price` и округляется по шагу `qtyStep`, извлекаемому вместе с `minOrderQty` и `minOrderAmt` через API. Если после округления стоимость оказывается ниже эффективного минимума, количество увеличивается. Перед отправкой ордера проверяется, что средств на кошельке достаточно; при продаже проверяется наличие актива в портфеле, минимальный размер позиции и минимальная стоимость сделки. Поэтому программа не должна пытаться купить на сумму, которой нет, или продавать больше, чем имеется — эти проверки присутствуют.

### 3. Очистка и повторные попытки

* **Механизм повтора.** Каждый торговый сигнал имеет счётчик `execution_attempts` и максимально три попытки исполнения. Если заявка не проходит, статус сигнала возвращается в «PENDING», и через следующую итерацию он будет обработан снова. После трёх неудачных попыток `cleanup_failed_signals` удаляет сигналы из очереди. Но из‑за описанной проблемы с проверкой `retCode` даже успешные сделки маркируются как неисполненные, поэтому счётчик быстро достигает трёх, и сигнал исчезает, не совершив сделку.

### 4. Как исправить и что проверить (информационно)

1. **Запускайте торговлю с флагом `--enable-trading` или нажатием кнопки.** Без включения торговли сигналы никогда не будут исполнены.
2. **Проверьте обработку ответа API при размещении ордера.** Либо измените `BybitClient.place_order` так, чтобы возвращался полный ответ с `retCode`, либо в `execute_buy_order` и `execute_sell_order` проверяйте наличие `orderId` в результате (в поле `result.orderId`), а не `retCode`. Сейчас условие `order_result.get('retCode')` всегда ложно, и все заявки считаются неудачными.
3. **Убедитесь, что `ticker_data` содержит поле `price24hPcnt` и что API тестнета возвращает достаточное число пар.** В противном случае генератор будет игнорировать большинство активов и выдавать мало сигналов. При необходимости можно снизить пороги ещё сильнее или убрать фильтр по объёму.
4. **Проверьте, что файл `adaptive_ml_performance.json` действительно читается.** В `TradingEngine.load_ml_data` он загружается из `src/strategies/models`, а в `DataCollector` путь указан абсолютный (на ваш локальный диск), что в контейнере не существует. Однако торговый движок использует свой метод, поэтому ML‑показатели должны подхватываться корректно.
5. **Просмотрите логи `trader_program`**, чтобы увидеть сообщения «Найдено … активных и … общих USDT‑пар для анализа», «Сгенерировано … новых сигналов» и «Сигнал BUY/SELL … не исполнен» — они помогут понять, откуда появляются только четыре сигнала.

Следуя этим рекомендациям, вы сможете понять причину зависания сигналов и настроить автоматическую торговлю без изменения интерфейса или уже работающих частей программы.
