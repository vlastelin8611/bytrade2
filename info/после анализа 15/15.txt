После обновления репозитория я внимательно исследовал весь проект. Ниже приведён детальный анализ текущего состояния торгового бота и рекомендации по решению указанных проблем (я привожу примеры кода, но сам код не изменяю).

---

## 1. Ограничение доли баланса, расходуемого на одну монету

В текущей реализации размер сделки вычисляется так:

* минимальная допустимая сумма (`effective_min_amount`) определяется на основе `minOrderAmt` из API, публичного минимума $5 и 10 % буфера;
* для каждой категории монет задаётся максимальный размер сделки (`max_trade_amount`): для BTCUSDT — максимум 20× `effective_min_amount` или $100; для ETH/BNB/LINK — максимум 4× `effective_min_amount` или $200; для остальных — 10× `effective_min_amount` или $50;
* затем сумма сделки вычисляется как `trade_amount = max(min(usdt_balance * self.risk_per_trade, max_trade_amount), effective_min_amount)`. Параметр `risk_per_trade` зафиксирован как `0.005`, то есть **0,5 %** от баланса.

Пользователь жалуется, что бот иногда покупает на весь баланс. В коде это возможно, если `self.risk_per_trade` будет изменён (например, в конфиге) или если баланс настолько мал, что `effective_min_amount` превышает `usdt_balance * self.risk_per_trade`. Текущая логика не учитывает общий размер позиции по символу: если цена монеты крайне низкая, даже 0,5 % баланса может привести к покупке огромного количества токенов.

### Как ограничить покупку одной монеты не более 50 % баланса

1. **Вычислять максимальную аллокацию для каждой сделки**:

   ```python
   max_allocation_per_coin = usdt_balance * 0.5  # 50 % от баланса
   trade_amount = max(min(usdt_balance * self.risk_per_trade,
                          max_trade_amount,       # ограничение по символу
                          max_allocation_per_coin),
                      effective_min_amount)
   ```

   Так бот никогда не потратит более половины баланса на одну монету, даже если `max_trade_amount` больше.

2. **Следить за суммарными позициями**: можно хранить стоимость всех открытых позиций по символу и пропускать сигнал, если стоимость позиции уже превышает лимит (например, 50 % баланса). Это позволит избегать «перекупки» одной монеты в несколько ордеров.

3. **Фильтровать сигналы по доступности**: ещё до добавления в очередь проверять, хватает ли USDT на минимальный ордер. В функции `add_signals` можно рассчитать эффективный минимум (`max(minOrderQty * price, minOrderAmt)`), сравнить с балансом и отбрасывать слишком дорогие сигналы. Это предотвратит накопление неисполняемых сигналов.

---

## 2. Ошибки вида «Order value exceeded lower limit» и «The quantity of a single market order must be less than the maximum allowed per order»

### 2.1. Случай «Order value exceeded lower limit»

Ошибка «Order value exceeded lower limit» возникает, когда итоговая стоимость ордера (количество × цена) ниже внутреннего минимального значения API. В коде уже добавлена логика, которая:

* берёт минимальную сумму из API (`minOrderAmt`), публичный минимум 5 USDT и умножает на буфер 10 %;
* вычисляет `trade_amount` с учётом `risk_per_trade` и `max_trade_amount`;
* после округления `qty` к шагу `qtyStep` пересчитывает сумму (`trade_usdt = qty * price`) и проверяет, что она не меньше `effective_min_check = max(minOrderQty * price, effective_min_amount)`; при необходимости увеличивает количество до минимально допустимого значения.

Тем не менее ошибки продолжают возникать на некоторых парах (например, BBSOLUSDT). Возможные причины:

1. **Банкнота с экстремально малой ценой**: округление `qty` к `qtyStep` может уменьшить стоимость ниже минимума. В коде уже введён буфер 10 %, но API Bybit иногда требует ещё больший запас. Увеличение буфера до 20 % или добавление фиксированной надбавки ($0,50–$1) может решить проблему.

2. **Лимиты по символу**: некоторые токены имеют внутренние ограничения, отличные от публичных. Для BBSOLUSDT реальный минимум может быть больше 5 USDT, поэтому нужно логировать ответ API (`get_instruments_info`) и выводить параметры `minOrderQty`, `minOrderAmt`, `qtyStep` и `maxMarketOrderQty`, что уже делается в функции `get_instrument_info`. Настоятельно рекомендую добавить детальное логирование в `execute_buy_order` для каждой проблемной сделки: отображать `effective_min_amount`, `base_min_amount`, `max_trade_amount`, `trade_amount`, `qty` и `trade_usdt`.

3. **Динамический буфер**: вместо фиксированного множителя можно вычислять буфер как функцию от волатильности или от количества знаков в `qtyStep`. Например, если `qtyStep` очень мелкий (1e‑8), добавлять +20–25 %. Это позволит удовлетворить скрытым требованиям API.

### 2.2. Случай «Quantity of a single market order must be less than the maximum allowed per order»

Для токенов с очень малой ценой (BABYDOGEUSDT и подобные) деление `trade_amount` на цену приводит к огромному количеству монет. В коде уже есть несколько барьеров:

* величина `qty` округляется по `qtyStep` и ограничивается «разумным пределом» в 1 трлн токенов;
* затем проверяется `max_order_qty` из API и `maxMarketOrderQty`; при превышении количество сокращается до максимума.

Однако сообщение об ошибке говорит, что лимит составляет ~1,23×10¹⁷, что сильно больше 1 трлн. По‑видимому, API для BABYDOGEUSDT возвращает гигантское значение `maxOrderQty` (возможно 0, что означает отсутствие лимита). Тогда наш «разумный предел» оказывается меньше лимита API, и заказ всё равно может превысить скрытое внутреннее ограничение.

**Что делать:**

1. **Снизить разумный предел**. Например, вместо 1×10¹² установить 1×10⁹ или 1×10⁸. Так количество BABYDOGE не превысит миллиард/сто миллионов, что соответствует значениям, упомянутым в сообщениях об ошибке.

2. **Рассчитывать максимальный объём исходя из `max_market_order_qty` или `maxOrderValue`**. Если API возвращает `maxOrderValue` (некоторые биржи делают это), можно ограничивать `trade_amount` так, чтобы `qty` не превышал соответствующий лимит.

3. **Пропускать слишком мелкие монеты**. Можно добавить фильтр: если `price * minOrderQty` < $0.001 или `qtyStep` < 1e-8, сигнал автоматически игнорируется. Это устранит заявки на мем‑монеты, где возможно переполнение.

4. **Делать частичную покупку**. Если `qty` превышает внутреннее ограничение, можно разбить ордер на несколько частей (например, десять ордеров по 10 % от расчётного размера). Однако тестнет может не разрешать такие серии ордеров.

---

## 3. Список проверенных проблем и их текущий статус

1. **Ограничение количества (maxOrderQty)**. 
   В функцию `execute_buy_order` добавлены проверки `max_order_qty`, `maxMarketOrderQty` и лимит «разумного предела». Ранее ордера могли отклоняться из‑за использования API‑параметра `maxOrderQty` без учёта `maxMarketOrderQty`; сейчас это исправлено. По логике количества проблема считается решённой, но на BABYDOGEUSDT всё ещё возможен перебор, поэтому потребуется уменьшить разумный предел или исключить символ.

2. **Минимальные суммы ордеров**. 
   В коде минимальная сумма рассчитывается как максимум из `minOrderAmt`, публичного минимума ($5) и специального минимума для ETH/BNB/LINK ($50), умноженных на буфер 10 %. Если `effective_min_amount` оказывается больше баланса, бот пропускает сигнал. Этот блок работает корректно, и ошибки для BTCUSDT, SOLUSDT, BNBUSDT и LINKUSDT больше не наблюдаются. Статус: **исправлено**.

3. **Ошибки округления**. 
   Добавлена функция правильного округления количества по шагу `qtyStep` с использованием `Decimal` и `math.floor`/`math.ceil`, повторный перерасчёт суммы и дополнительная проверка против минимального лимита. Также есть корректировки при превышении максимума и проверка доступного баланса. Проблема «$5.28 отклоняется при минимуме $5» действительно была минимизирована за счёт буфера 10 %, но для некоторых токенов (BBSOLUSDT) она остаётся. Статус: **частично решена**.

4. **BBSOLUSDT**. 
   Для этого символа ошибки продолжаются. В коде нет индивидуальной логики по BBSOLUSDT, поэтому бот рассчитывает минимальный ордер как $5.0 × 1.1 = $5.50 и пытается купить. Вероятно, реальные минимальные суммы для этой пары выше либо шаг `qtyStep` заставляет количество уменьшаться до нуля. Статус: **не решено**. Необходимо включить детальный лог для конкретного символа и, возможно, установить отдельный минимум (например, $20), либо временно исключить BBSOLUSDT из торговли.

---

## 4. Telegram‑уведомления и inline‑кнопки

Файл `telegram_notifier.py` реализует полноценного асинхронного бота:

* бот инициализируется через `initialize_bot`, добавляет обработчики callback‑кнопок и команд `/start`, `/balance` и `/stop_trading`;
* отправка сообщений осуществляется через очередь и отдельный worker‑поток; сообщения поддерживают inline‑кнопки;
* при отправке сообщения о сделке в методе `notify_trade_executed` формируются две кнопки: «Баланс» (`callback_data="get_balance"`) и «Стоп» (`callback_data="stop_trading"`);
* метод `_handle_callback` обрабатывает нажатия кнопок и вызывает соответствующие callback‑функции из словаря `self.callbacks`.

В `TraderMainWindow` при инициализации Telegram‑нотификатора устанавливаются функции `get_balance_for_telegram` и `stop_trading_for_telegram` как callback‑обработчики, а затем запускается polling. Метод `get_balance_for_telegram` формирует текст баланса для каждого актива, а `stop_trading_for_telegram` выключает торговлю и возвращает сообщение.

Если при нажатии на кнопки в Telegram ничего не происходит, возможны причины:

1. **Бот не запустил polling**. Проверьте, вызывается ли `start_polling` (это происходит в `init_telegram_notifier`). Если бот создан до установки callback‑функций, polling может не стартовать. Рекомендуется после установки колбеков явно вызывать `telegram_notifier.start_polling()`.

2. **Отсутствие valid token/chat id**. Проверьте, что в файле `telegram_settings.json` сохранены правильные `token` и `chat_id`, и флажок «включить уведомления» активирован. Тестовую отправку можно выполнить через кнопку «Отправить тест» — она использует `send_test_message` в `TelegramNotifier`.

3. **Ошибка в callback‑функциях**. Функции должны возвращать строку; если они возвращают `None` или выбрасывают исключение, бот не сможет отредактировать сообщение. Убедитесь, что `get_balance_for_telegram` всегда возвращает текст (даже при пустом портфеле).

---

## 5. Рекомендации по дальнейшим улучшениям

1. **Динамический риск‑менеджмент**.
   Текущий параметр `risk_per_trade` фиксирован (0,5 % баланса). Его можно динамически вычислять на основе количества открытых позиций, волатильности рынка или профиля риска пользователя. Например, уменьшать долю при высокой волатильности.

2. **Система адаптивных буферов**.
   Вместо постоянного множителя 1.10 можно вычислять буфер как функцию от шага `qtyStep` или цены: чем меньше `qtyStep` и чем дешевле монета, тем больший буфер нужен. Для проблемных монет — отдельные коэффициенты. В таблице настроек можно хранить словарь символов и их коэффициентов.

3. **Индивидуальные лимиты `max_trade_amount`**.
   Сейчас `max_trade_amount` жёстко привязан к категориям монет. Можно рассчитывать лимит как `effective_min_amount * N`, где `N` выбирается в зависимости от баланса и риска. Чем выше баланс, тем больше можно инвестировать, но не более половины баланса.

4. **Мониторинг ошибок и отчёты**.
   Создайте модуль мониторинга, который собирает статистику ошибок торговли (тип символа, время, API‑ответ). Это поможет выявить паттерны и адаптировать логику.

5. **Улучшение логирования**.
   Чтобы диагностировать проблемы вроде BBSOLUSDT, логируйте все промежуточные значения: `min_trade_amount`, `effective_min_amount`, `max_trade_amount`, `trade_amount`, `qty` перед округлением, `qty` после округления, `trade_usdt`, `min_order_qty`, `min_order_amt`, `max_order_qty` и `qtyStep`. Файл логов позволит сравнивать ожидания и фактические ошибки API.

6. **Пропуск нежелательных монет**.
   Добавьте список исключений, где явно указываются символы, запрещённые для торговли (например, BBSOLUSDT, если ошибка не решена). В `SignalGenerator` можно проверять `if symbol in banned_symbols: continue`.

7. **Отображение истории сделок**.
   В истории сделок заголовки таблицы уже окрашены в тёмный цвет с белым текстом; ячейки имеют белый фон и тёмно‑серый текст. Если текст всё ещё «сливается», убедитесь, что стили таблицы не переопределяются где‑то ещё. Можно явно задать `color: #2c3e50; background-color: #ffffff;` для ячеек. Также стоит добавлять в историю только успешные сделки (когда API возвращает `orderId`), чтобы исключить фиктивные записи.

8. **Дополнительные команды Telegram**.
   В `TelegramNotifier` уже добавлены команды `/balance` и `/stop_trading`. Можно расширить список, например, добавив `/start_trading` или `/stats`. Все команды должны использовать callbacks, как реализовано в `_handle_balance_command` и `_handle_stop_trading_command`.

---

## Заключение

Обновлённый бот существенно улучшил управление ордерами: добавлены буферы к минимальным суммам, правильное округление количества и учёт максимальных величин, а также интерфейс Telegram с inline‑кнопками. Однако остаются проблемы с некоторыми токенами (например, BBSOLUSDT) и с тем, что бот потенциально может расходовать слишком большую долю баланса на одну монету. Для решения этих вопросов рекомендую:

* ограничивать `trade_amount` половиной баланса;
* снизить разумный предел количества и добавить фильтр по мелким токенам;
* ввести динамический буфер и индивидуальные настройки для проблемных символов;
* усилить логирование и мониторинг ошибок;
* убедиться, что Telegram‑callback‑функции корректно настроены и polling запущен.

Следуя этим рекомендациям и приведённым примерам кода, вы сможете сделать торговлю более безопасной, гибкой и эффективной при сохранении короткосрочной стратегии.
