1. Проблемы с торговым алгоритмом
1.1. Чрезмерное расходование баланса

В функции execute_buy_order сумма сделки вычисляется как
# trade_amount – 1 % от USDT баланса, но не меньше `effective_min_amount`
trade_amount = max(min(usdt_balance * 0.01, max_trade_amount), effective_min_amount)

Это означает, что даже при балансе 1000 USDT бот каждую сделку будет пытаться совершить примерно на 10 USDT (1 % от баланса). В ваших логах сумма max_аллокация равна 6.21 USDT при балансе 12.43 USDT — это уже 50 % баланса, что указывает на ошибку: где‑то переменную риска неправильно интерпретировали. В конфигурации установлено MAX_POSITION_PERCENT = 0.03 (3 % на сделку)
raw.githubusercontent.com
, но в коде модуля trader_program.py риск жёстко прописан как 1 %. Поэтому при большом портфеле бот может купить слишком много одной монеты.

Рекомендация: рассчитывать сумму сделки как часть баланса, но ограничить сверху половиной баланса и снизу минимальной суммой для ордера. Например:
# config.MAX_POSITION_PERCENT – 0.03 (3 %)
max_allocation_per_coin = usdt_balance * MAX_POSITION_PERCENT
# ограничиваем трату на монету максимум половиной баланса
max_allocation_per_coin = min(max_allocation_per_coin, usdt_balance * 0.5)
trade_amount = max(min(max_allocation_per_coin, max_trade_amount), effective_min_amount)
Так бот никогда не потратит на одну монету больше 3 % баланса (или 50 %, если вы хотите временно увеличить риск).

1.2. Минимальные и максимальные размеры ордера

В Bybit существуют внутренние ограничения, которые строже публичных. На основе анализа логов и кода:

Минимальная сумма для большинства монет — 5 USDT (прописано в коде и подхватывается из API). Для дорогих монет (BTC, ETH, BNB, LINK) бот увеличивает минимум до 50 USDT
raw.githubusercontent.com
.

После округления количества по qtyStep сумма может стать меньше требуемой, поэтому в коде количество увеличивается до минимального
raw.githubusercontent.com
.

Для некоторых активов, например BBSOLUSDT, ордера все равно отклоняются с ошибкой «Order value exceeded lower limit». Это значит, что реальный минимум выше, чем 5.10 USDT. Для таких символов стоит либо увеличить буфер (например, minOrderAmt × 1.5), либо исключить их из торговли.

Для очень дешёвых монет, например BABYDOGEUSDT, количество токенов по минимальной сумме получается огромным (миллиарды штук), что приводит к ошибкам типа «The quantity of a single market order must be less than the maximum allowed per order». Хотя лимит API показывает 1.23×10¹⁷, у Bybit могут быть дополнительные ограничения на подобные “adventure” токены. Лучше вообще исключить такие пары или снизить «разумный предел» количества.

Рекомендации для покупки:

Проверять лимиты до выставления ордера. Параметры minOrderQty, maxOrderQty, minOrderAmt, maxMarketOrderQty и qtyStep берутся из API. Перед покупкой надо убедиться, что рассчитанное количество не превышает maxMarketOrderQty, и уменьшить его при необходимости.

Использовать динамический буфер для effective_min_amount. Вместо фиксированного множителя 1.10 можно вычислять буфер в зависимости от волатильности или количества знаков после запятой. Например:
if symbol in problematic_symbols:
    buffer_mult = 1.50  # 50 % буфер для BBSOL
else:
    # буфер больше для монет с малым шагом qtyStep
    buffer_mult = 1 + (0.05 if qty_step < 1e-6 else 0.10)
effective_min_amount = min_trade_amount * buffer_mult
Фильтровать символы. Добавьте список исключённых пар (например, ["BBSOLUSDT", "BABYDOGEUSDT"]). В генераторе сигналов игнорируйте эти символы.

Ограничивать количество дешёвых токенов. Если цена монеты ниже 0.0000001, пропускайте сигнал или ограничивайте максимальное qty одним миллионом токенов.

Пропускать сигналы при недостаточном балансе. В методе add_signals проверять: если USDT меньше чем эффективный минимум для символа, сигнал не добавлять в очередь.

1.3. Проблемы с продажей

В execute_sell_order монета продаётся половиной от баланса по символу
raw.githubusercontent.com
. Это хорошо для фиксации прибыли, но приводит к ошибке «Стоимость продажи $3.96 меньше минимальной $5.00» при маленьких позициях. Текущая логика сразу отменяет продажу, не пробуя продать полный объём.

Рекомендация: если 50 % меньше минимума, попробовать продать весь объём, и только если даже полный объём меньше минимума, пропустить продажу.
sell_amount = asset_balance * 0.5
if sell_amount * price < min_order_amt:
    sell_amount = asset_balance  # продаём всю позицию
if sell_amount * price < min_order_amt:
    log("⚠️ Сумма продажи слишком мала")
    return False
1.4. Генерация сигналов и малое количество сделок

В классе SignalGenerator минимальная уверенность (min_confidence) уменьшена до 0.1, а для технического анализа порог роста/падения 24 часов — 0.03 %
raw.githubusercontent.com
. Тем не менее бот часто остаётся без сделок. По логам видно, что каждый цикл генерируется 5 сигналов, но ордера отклоняются по лимитам. Поэтому:

уменьшите минимальные пороги ещё сильнее (например, 0.01 %) или добавьте анализ более коротких таймфреймов (15 мин, 1 ч), чтобы находить больше возможностей;

фильтруйте сигналы по доступности. Нет смысла добавлять в очередь сигнал, если USDT меньше минимального размера ордера;

увеличьте параметр max_signals_per_iteration (10) либо уменьшите паузу между итерациями, чтобы очередь не застаивалась.

2. Ошибки Telegram‑уведомлений и callback‑кнопок

Файл telegram_notifier.py реализует полноценный бот с очередью сообщений, кнопками и обработчиками callback_query
raw.githubusercontent.com
. В логе видно, что тестовые сообщения отправляются, но нажатия кнопок «Баланс»/«Стоп» не работают. Основные причины:

Polling не запущен. Метод start_polling существует в классе, но в TraderMainWindow его не вызывают после установки callback‑функций. Без polling бот не получает события.

Функции‑обработчики должны возвращать строку. В callback‑функциях get_balance_for_telegram и stop_trading_for_telegram нужно возвращать текст; если функция возвращает None, бот не знает, что отправлять.

Как исправить

В TraderMainWindow нужно добавить инициализацию Telegram, чтобы настроить бота и запустить polling:
from telegram_notifier import TelegramNotifier

class TraderMainWindow(QMainWindow):
    def __init__(self, ...):
        ...
        self.telegram_notifier = None
        self.init_telegram_tab()  # создаёт вкладку настроек Telegram
        ...

    def init_telegram_tab(self):
        # Здесь нужно считать token и chat_id из настроек и создать notifier
        token = self.settings.value('telegram_token', '')
        chat_id = self.settings.value('telegram_chat_id', '')
        self.telegram_notifier = TelegramNotifier(token, chat_id)
        # Устанавливаем callback‑функции
        self.telegram_notifier.set_callback('get_balance', self.get_balance_for_telegram)
        self.telegram_notifier.set_callback('stop_trading', self.stop_trading_for_telegram)
        # Запускаем polling
        self.telegram_notifier.start_polling()

    def get_balance_for_telegram(self):
        # Возвращаем строку с балансом
        usdt = self.trading_engine.portfolio.get('USDT', 0)
        lines = [f"Баланс USDT: {usdt:.2f}"]
        for coin, amount in self.trading_engine.portfolio.items():
            if coin != 'USDT' and amount > 0:
                lines.append(f"{coin}: {amount}")
        return '\n'.join(lines)

    def stop_trading_for_telegram(self):
        self.stop_trading()
        return "Торговля остановлена по запросу из Telegram"

При отправке уведомлений о сделках (notify_trade_executed, notify_balance_change, notify_trading_status, notify_error) обязательно передавайте inline‑кнопки, как показано в telegram_notifier.py
raw.githubusercontent.com
.

3. Другие наблюдения и советы
Проверка соотношения риск/доходность. Добавьте метрику просадки (max_drawdown_percent в конфигурации уже есть) и реализуйте защиту: если просадка превышает 10–15 %, останавливайте торговлю и отправляйте уведомление.

Система мониторинга ошибок. Создайте декоратор или отдельный модуль для логирования всех ошибок с символами, суммами и API‑ответами. Это поможет оперативно выявлять пары с некорректными лимитами (как BBSOLUSDT) и исключать их.

Обработка небольших балансов. Если USDT‑баланс меньше 10 USDT, лучше не торговать: большинство минимальных ордеров требуют ~5 USDT, а комиссия и округление могут привести к отклонению. Логи показали, что при балансе ~12 USDT почти все ордера отклонялись.

Оптимизируйте Telegram‑GUI. Поля для ввода токена и chat ID должны проверять корректность формата, а кнопка «Проверить» должна отправлять тестовое сообщение. Сохраните настройки в telegram_settings.json и загружайте их при старте программы.

Итог

Проблемы с торговлей возникают из‑за несоответствия минимальных сумм ордеров и ограничений Bybit, некорректного расчёта риска и отсутствия фильтрации по балансу. Telegram‑уведомления не работают, потому что бот не запускает polling и callback‑функции возвращают None.

Внедрив предложенные изменения — ограничив долю баланса на одну позицию, исключив проблемные токены, добавив динамический буфер, исправив логику продажи, фильтруя сигналы по доступности, и корректно настроив Telegram‑бот — вы сделаете торговлю более активной и безопасной, а уведомления станут работать как ожидается.